# Algorithms and Data Structures

This repository contains implementations and explanations of fundamental **algorithms** and **data structures**. Each code file includes comprehensive comments to provide insights into the logic and functionality. The goal is to deepen understanding of core concepts while solving problems efficiently.

## üìÇ Topics Covered

### **Data Structures**
- **Stack**: A linear data structure following the LIFO (Last In, First Out) principle, used for tasks like function calls and undo operations.
- **Queue**: A FIFO (First In, First Out) data structure, ideal for managing tasks in sequential order, such as processing requests.
- **PriorityQueue**: A specialized queue where elements are dequeued based on priority rather than insertion order.
- **LinkedList**: A dynamic data structure consisting of nodes linked sequentially, useful for scenarios requiring frequent insertion and deletion.
- **ArrayList**: A resizable array implementation that provides random access and dynamic resizing.
- **Dynamic Array**: Similar to an ArrayList, allows dynamic resizing to accommodate data growth.
- **Hash Tables**: A structure that maps keys to values efficiently using hashing.
- **Graph**:
  - **Adjacency Matrix**: A 2D matrix representing graph connections.
  - **Adjacency Lists**: A list-based representation of graph edges.
  - **Depth First Search (DFS)**: Explores as far as possible along each branch before backtracking.
  - **Breadth First Search (BFS)**: Traverses nodes level by level in a graph.
- **Tree Data Structures**:
  - **Binary Search Trees (BST)**: Trees where each node's left child is smaller and the right child is larger.
  - **Tree Traversal**: Techniques like in-order, pre-order, and post-order to visit tree nodes.

### **Algorithms**
- **Big-O Notation**: Analysis of algorithm performance in terms of time and space complexity.
- **Recursion**: A technique where functions call themselves to solve smaller instances of a problem.
- **Sorting Algorithms**:
  - **Selection Sort**: Repeatedly selects the smallest element from the unsorted section and places it at the start.
  - **Quick Sort**: A divide-and-conquer algorithm that partitions data and sorts subarrays recursively.
  - **Merge Sort**: A stable sorting method that divides the array into halves, sorts them, and merges them back.
  - **Insertion Sort**: Inserts elements into their correct position one at a time.
  - **Bubble Sort**: Compares adjacent elements and swaps them to sort the array.
- **Search Algorithms**:
  - **Linear Search**: Sequentially searches for a target in an array.
  - **Binary Search**: Efficiently finds an element in a sorted array by dividing the search interval in half.
  - **Interpolation Search**: Enhances binary search by predicting element location.
- **Execution Time**: Practical analysis of code runtime for different algorithms.

---

## üöÄ How to Use
- Each file includes:
  - **Code Implementation**: Solutions for problems using specific algorithms and data structures.
  - **Detailed Comments**: Explanation of logic, steps, and Big-O complexity.
- Browse the repository to explore topics and understand the concepts step by step.

---

## üõ†Ô∏è Purpose
This repository serves as a resource for:
- Strengthening problem-solving and coding skills.
- Preparing for technical interviews.
- Building a solid foundation in algorithms and data structures.

Feel free to explore, learn, and improve! Contributions and feedback are welcome. üòä
